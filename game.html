<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Tycoon Card Game</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
<style>
html, body { margin:0; padding:0; width:100%; height:100%; background-color:#111; overflow:hidden; }
#game-container { width:100%; height:100%; position:relative; overflow:hidden; }
#game-container canvas { transform-origin: top left; display:block; position:absolute; }
</style>
</head>
<body>
<div id="game-container"></div>

<script>
class TycoonUI extends Phaser.Scene {
  constructor() {
    super();
    this.deck = [];
    this.hands = [];
    this.table = [];
    this.currentPlayer = 0;
    this.passesInRow = 0;
    this.revolution = false;
    this.selectedCards = [];
    this.selectedRank = null;
    this.handImages = [];
    this.tableImages = [];
    this.frames = {};
    this.orderedFrames = [];
  }

  preload() {
    this.load.image('cardsheet', 'https://davymaldonado.github.io/tycoongame/cards.png');
  }

  create() {
    this.createFrames();
    this.initDeck();
    this.dealCards(4); // 54 cards

    this.statusText = this.add.text(20, 20, "Your turn!", { fontSize: "20px", color: "#fff" });

    // Buttons
    this.passBtn = this.add.text(50, 600, "[ PASS ]", { fontSize:"28px", color:"#f44", backgroundColor:"#222", padding:{x:10,y:5}})
      .setInteractive().on("pointerdown", ()=>this.playerPass());
    this.playBtn = this.add.text(250, 600, "[ PLAY ]", { fontSize:"28px", color:"#4f4", backgroundColor:"#222", padding:{x:10,y:5}})
      .setInteractive().on("pointerdown", ()=>this.playerAttemptPlay());

    this.renderHand(0); // render player hand
  }

  createFrames() {
    const cardWidth = 147, cardHeight = 240, leftMargin = 11, topGap = 3;
    const columnGap = 22, rowGap = 4;
    const suits = ['♣','♦','♥','♠'];
    const ranks = [14,2,3,4,5,6,7,8,9,10,11,12];

    for(let r=0;r<4;r++){
      const suit = suits[r];
      for(let c=0;c<12;c++){
        const x = leftMargin + c*(cardWidth+columnGap);
        const y = topGap + r*(cardHeight+rowGap);
        const key = `${ranks[c]}${suit}`;
        this.frames[key] = {x,y,width:cardWidth,height:cardHeight};
        this.orderedFrames.push(key);
      }
    }

    const specialRowIndex = 4;
    const specialCols = ['Joker','Joker','Back','K♣','K♦','K♥','K♠'];
    specialCols.forEach((key,col)=>{
      const x = leftMargin + col*(cardWidth+columnGap);
      const y = topGap + specialRowIndex*(cardHeight+rowGap);
      this.frames[key] = {x,y,width:cardWidth,height:cardHeight};
      if(key!=='Back') this.orderedFrames.push(key);
    });
  }

  createCardImage(frame){
    if(!frame) return null;
    const {x,y,width,height}=frame;
    const key = `card_${x}_${y}`;
    if(!this.textures.exists(key)){
      const img=this.textures.get('cardsheet').getSourceImage();
      const canvas=this.textures.createCanvas(key,width,height);
      const ctx=canvas.getContext('2d');
      ctx.drawImage(img,x,y,width,height,0,0,width,height);
      canvas.refresh();
    }
    return this.add.image(0,0,key).setOrigin(0.5,0.5).setInteractive({useHandCursor:true});
  }

  shuffle(array){
    for(let i=array.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [array[i],array[j]]=[array[j],array[i]];
    }
    return array;
  }

  initDeck() {
    const suits=["♠","♥","♦","♣"];
    this.deck=[];
    for(let s of suits) for(let r=3;r<=15;r++) this.deck.push({rank:r,suit:s});
    this.deck.push({rank:16,suit:"🃏"});
    this.deck.push({rank:16,suit:"🃏"});
    Phaser.Utils.Array.Shuffle(this.deck);
  }

  dealCards(numPlayers){
    this.hands = Array.from({length:numPlayers}, ()=>[]);
    let i=0;
    while(this.deck.length>0){
      this.hands[i%numPlayers].push(this.deck.pop());
      i++;
    }
    this.hands.forEach(hand=>hand.sort((a,b)=>a.rank-b.rank));
  }

  cardToKey(card){
    const ranks={11:"J",12:"Q",13:"K",14:"A",15:"2",16:"Joker"};
    if(card.rank===16) return "Joker";
    if(card.rank===13) return "K"+card.suit;
    if(card.rank===12) return "Q"+card.suit;
    if(card.rank===11) return "J"+card.suit;
    if(card.rank===14) return "A"+card.suit;
    if(card.rank===15) return "2"+card.suit;
    return card.rank+card.suit;
  }

  renderHand(playerIndex){
    if(this.handImages) this.handImages.forEach(t=>t.destroy());
    this.handImages=[];

    const hand = this.hands[playerIndex];
    const screenWidth = 1280, screenHeight = 720;
    const centerX = screenWidth/2;
    const bottomY = screenHeight-150;
    const baseSpacing = 60;
    const maxRotation = Phaser.Math.DegToRad(20);

    const updatePositions = (hoverIndex=null, scaleFactor=1.4)=>{
      const total = hand.length;
      for(let i=0;i<total;i++){
        const img = this.handImages[i];
        const dx=(i-(total-1)/2)/((total-1)/2);
        const rotation = dx*maxRotation;
        const y = bottomY - dx*dx*-50;
        let spacing = baseSpacing;
        let scale = 1;
        if(hoverIndex!==null){
          if(i===hoverIndex) scale=scaleFactor;
          spacing=baseSpacing*(hoverIndex===null?1:1+(i===hoverIndex?0.2:0.1));
        }
        const x = centerX - ((total-1)*spacing)/2 + i*spacing;
        img.setPosition(x,y);
        img.setRotation(rotation);
        img.setScale(scale);
      }
    };

    // Create images
    hand.forEach((card,i)=>{
      const key = this.cardToKey(card);
      const img = this.createCardImage(this.frames[key]);
      img.setData('card',card);
      img.setData('index',i);

      img.on('pointerdown', ()=>{
        if(this.selectedRank && card.rank!==this.selectedRank) return;
        if(this.selectedCards.includes(card)){
          this.selectedCards.splice(this.selectedCards.indexOf(card),1);
          img.clearTint();
        } else {
          if(this.selectedCards.length===0)this.selectedRank=card.rank;
          this.selectedCards.push(card);
          img.setTint(0x8888ff);
        }
      });

      img.on('pointerover', ()=>updatePositions(i));
      img.on('pointerout', ()=>updatePositions(null));
      this.handImages.push(img);
    });

    updatePositions(null); // <-- THIS ensures cards are centered immediately
  }

  getTopSet(){ return this.table.length>0?this.table[this.table.length-1]:null; }

  canPlaySet(cards){
    if(cards.length===0)return false;
    if(!cards.every(c=>c.rank===cards[0].rank))return false;
    let topSet=this.getTopSet();
    if(!topSet)return true;
    if(cards.length!==topSet.length)return false;
    let top=topSet[0],rank=cards[0].rank;
    if(top.rank===16 && rank===3 && cards[0].suit==="♠")return true;
    return this.revolution?rank<top.rank:rank>top.rank;
  }

  playerAttemptPlay(){
    if(this.currentPlayer!==0)return;
    if(!this.canPlaySet(this.selectedCards)){
      this.statusText.setText("Invalid play!"); return;
    }
    this.playCard(0,this.selectedCards);
    this.selectedCards=[]; this.selectedRank=null;
    this.renderHand(0);
    this.nextTurn();
  }

  playerPass(){
    if(this.currentPlayer!==0)return;
    this.passesInRow++;
    this.statusText.setText("You pass!");
    this.nextTurn();
  }

  playCard(playerIndex,cards){
    this.hands[playerIndex] = this.hands[playerIndex].filter(c=>!cards.includes(c));
    this.table.push(cards);

    const yBase=300, spacingY=60, xCenter=500;
    cards.forEach((card,i)=>{
      const totalWidth=cards.length*40;
      const x = xCenter-totalWidth/2 + i*40;
      const key=this.cardToKey(card);
      const img=this.createCardImage(this.frames[key]);
      img.setPosition(x,yBase+(this.table.length-1)*spacingY);
      this.tableImages.push(img);
    });

    this.passesInRow=0;
    if(cards.length===4){
      this.revolution=!this.revolution;
      this.add.text(300,200,"REVOLUTION!",{fontSize:"32px",color:"#f0f"});
    }
  }

  aiTurn(playerIndex){
    let topSet=this.getTopSet();
    let requiredCount=topSet?topSet.length:1;
    let ranks=[...new Set(this.hands[playerIndex].map(c=>c.rank))];
    for(let r of ranks){
      let candidates=this.hands[playerIndex].filter(c=>c.rank===r).slice(0,requiredCount);
      if(candidates.length===requiredCount && this.canPlaySet(candidates)){
        this.playCard(playerIndex,candidates);
        return;
      }
    }
    this.passesInRow++;
  }

  nextTurn(){
    if(this.hands[0].length===0){ this.statusText.setText("You win!"); return; }
    this.currentPlayer=(this.currentPlayer+1)%4;
    if(this.currentPlayer===0){
      this.statusText.setText("Your turn!");
      this.renderHand(0);
    } else {
      this.statusText.setText("AI "+this.currentPlayer+"'s turn...");
      this.time.delayedCall(1000, ()=>{ this.aiTurn(this.currentPlayer); this.nextTurn(); });
    }
    if(this.passesInRow>=3){
      this.tableImages.forEach(img=>img.destroy());
      this.tableImages=[];
      this.table=[];
    }
  }
}

const config = {
  type: Phaser.AUTO,
  width:1280,
  height:720,
  backgroundColor:"#1d1d1d",
  scene: TycoonUI,
  parent:"game-container"
};

const game = new Phaser.Game(config);

function resizeGame(){
  const container=document.getElementById("game-container");
  const canvas=container.querySelector("canvas");
  const scale=Math.min(container.clientWidth/1280, container.clientHeight/720);
  const offsetX=(container.clientWidth - 1280*scale)/2;
  const offsetY=(container.clientHeight - 720*scale)/2;
  canvas.style.transform=`translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
}
window.addEventListener("resize", resizeGame);
window.addEventListener("load", resizeGame);
</script>
</body>
</html>
