<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Tycoon Multi-Card Improved</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
<script>
class TycoonScene extends Phaser.Scene {
  constructor() {
    super();
    this.deck = [];
    this.hands = [];
    this.table = [];
    this.currentPlayer = 0;
    this.passesInRow = 0;
    this.revolution = false;

    this.selectedCards = [];
    this.selectedRank = null;
  }

  preload() {}

  create() {
    this.initDeck();
    this.dealCards(4);

    this.tableTexts = [];

    this.statusText = this.add.text(20, 20, "Your turn!", {fontSize:"20px", color:"#fff"});
    this.renderHand(0);

    // Pass button
    this.passBtn = this.add.text(50, 450, "[ PASS ]", {fontSize:"28px", color:"#f44", backgroundColor:"#222", padding:{x:10,y:5}})
      .setInteractive().on("pointerdown", ()=>this.playerPass());

    // Play button
    this.playBtn = this.add.text(200, 450, "[ PLAY ]", {fontSize:"28px", color:"#4f4", backgroundColor:"#222", padding:{x:10,y:5}})
      .setInteractive().on("pointerdown", ()=>this.playerAttemptPlay());
  }

  initDeck() {
    const suits=["â™ ","â™¥","â™¦","â™£"];
    this.deck=[];
    for(let s of suits) for(let r=3;r<=15;r++) this.deck.push({rank:r,suit:s});
    this.deck.push({rank:16,suit:"ðŸƒ"}); // Joker
    Phaser.Utils.Array.Shuffle(this.deck);
  }

  dealCards(numPlayers){
    this.hands=Array.from({length:numPlayers},()=>[]);
    let i=0;
    while(this.deck.length>0){ this.hands[i%numPlayers].push(this.deck.pop()); i++; }
    this.hands.forEach(hand=>hand.sort((a,b)=>a.rank-b.rank));
  }

  cardToString(card){ const ranks={11:"J",12:"Q",13:"K",14:"A",15:"2",16:"Joker"}; return (ranks[card.rank]||card.rank)+card.suit; }

  renderHand(playerIndex) {
    if(this.handTexts) this.handTexts.forEach(t=>t.destroy());
    this.handTexts=[];
    // Reset selectedCards if needed
    if(this.selectedCards.length === 0) this.selectedRank = null;

    let hand = this.hands[playerIndex];

    // Determine required count from table
    let topSet = this.getTopSet();
    let requiredCount = topSet ? topSet.length : 1;

    hand.forEach((card, i) => {
        let txt = this.add.text(50 + i*40, 500, this.cardToString(card), { fontSize:"24px", color:"#fff" }).setInteractive();

        // Determine if card is selectable
        let canSelect = true;

        // If table requires a set, card count must match
        if(topSet && hand.filter(c => c.rank === card.rank).length < requiredCount) canSelect = false;

        // If one or more cards are selected, only allow same rank
        if(this.selectedRank && card.rank !== this.selectedRank) canSelect = false;

        txt.setAlpha(canSelect ? 1 : 0.3);

        txt.on("pointerdown", () => {
            if(!canSelect) return;
            this.toggleSelect(card, txt);
        });

        this.handTexts.push(txt);
    });
}


  toggleSelect(card, txtObj) {
    let idx = this.selectedCards.indexOf(card);
    if(idx >= 0) {
        this.selectedCards.splice(idx,1);
        txtObj.setStyle({backgroundColor:null});
        if(this.selectedCards.length === 0) this.selectedRank = null;
    } else {
        if(this.selectedCards.length === 0) this.selectedRank = card.rank;
        this.selectedCards.push(card);
        txtObj.setStyle({backgroundColor:"#444"});
    }
    // Re-render to update dimming for other cards
    this.renderHand(0);
}


  getTopSet(){ return this.table.length>0?this.table[this.table.length-1]:null; }

  canPlaySet(cards){
    if(cards.length===0) return false;
    if(!cards.every(c=>c.rank===cards[0].rank)) return false;
    let topSet=this.getTopSet();
    if(!topSet) return true;

    // Must match the number of cards
    if(cards.length!==topSet.length) return false;

    let top=topSet[0];
    let rank=cards[0].rank;

    // Exception: 3â™  on Joker
    if(top.rank===16 && rank===3 && cards[0].suit==="â™ ") return true;

    if(this.revolution) return rank<top.rank;
    return rank>top.rank;
  }

  playerAttemptPlay(){
    if(this.currentPlayer!==0) return;
    if(!this.canPlaySet(this.selectedCards)){ this.statusText.setText("Invalid play!"); return; }
    this.playCard(0,this.selectedCards);
    this.selectedCards=[];
    this.selectedRank=null;
    this.renderHand(0);
    this.nextTurn();
  }

  playerPass(){
    if(this.currentPlayer!==0) return;
    this.passesInRow++;
    this.statusText.setText("You pass!");
    this.nextTurn();
  }

  playCard(playerIndex,cards){
    this.hands[playerIndex]=this.hands[playerIndex].filter(c=>!cards.includes(c));
    this.table.push(cards);

    // dynamic table layout: center each set
    let yBase=300;
    let spacingY=60;
    let xCenter=500;

    cards.forEach((card,i)=>{
      let totalWidth=cards.length*40;
      let x=xCenter - totalWidth/2 + i*40;
      let txt=this.add.text(x, yBase + (this.table.length-1)*spacingY,this.cardToString(card),{fontSize:"28px",color:"#ff0"});
      this.tableTexts.push(txt);
    });

    this.passesInRow=0;

    if(cards.some(c=>c.rank===8)) this.clearPile("8-Cut!");

    // Joker followed by 3â™ 
    let prevSet=this.table.length>=2?this.table[this.table.length-2]:null;
    if(prevSet && prevSet[0].rank===16 && cards[0].rank===3 && cards[0].suit==="â™ "){
      this.clearPile("3 of Spades clears Joker!");
    }

    // Revolution check
    if(cards.length===4){
      this.revolution=!this.revolution;
      this.add.text(300,200,"REVOLUTION!",{fontSize:"32px",color:"#f0f"});
    }
  }

  clearPile(message){
    this.table=[];
    if(this.tableTexts){ this.tableTexts.forEach(t=>t.destroy()); this.tableTexts=[];}
    if(this.clearMsg) this.clearMsg.destroy();
    this.clearMsg=this.add.text(300,250,message,{fontSize:"28px",color:"#0f0"});
    this.clearMsg.setAlpha(1);
    this.tweens.add({targets:this.clearMsg,alpha:0,duration:1500,ease:"Linear",onComplete:()=>{if(this.clearMsg){this.clearMsg.destroy(); this.clearMsg=null;}}});
    this.passesInRow=0;
  }

  aiTurn(playerIndex){
    let topSet=this.getTopSet();
    let requiredCount=topSet?topSet.length:1;
    // find all possible sets with exact required count
    let ranks=[...new Set(this.hands[playerIndex].map(c=>c.rank))];
    for(let r of ranks){
      let candidates=this.hands[playerIndex].filter(c=>c.rank===r).slice(0,requiredCount);
      if(candidates.length===requiredCount && this.canPlaySet(candidates)){
        this.playCard(playerIndex,candidates);
        return;
      }
    }
    this.passesInRow++;
    console.log("AI",playerIndex,"passes");
  }

  nextTurn(){
    if(this.hands[0].length===0){ this.statusText.setText("You win!"); return; }
    this.currentPlayer=(this.currentPlayer+1)%4;

    if(this.currentPlayer===0){
      this.statusText.setText("Your turn!");
      this.renderHand(0);
    } else {
      this.statusText.setText("AI "+this.currentPlayer+"'s turn...");
      this.time.delayedCall(1000,()=>{this.aiTurn(this.currentPlayer); this.nextTurn();});
    }

    if(this.passesInRow>=3) this.clearPile("Pile Cleared");
  }
}

const config={type:Phaser.AUTO,width:1000,height:600,backgroundColor:"#2d2d2d",scene:TycoonScene};
new Phaser.Game(config);
</script>
</body>
</html>
