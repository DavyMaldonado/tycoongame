<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Tycoon Multi-Card Improved</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
<script>
// Constants for better maintainability
const JOKER_RANK = 16;
const JOKER_EFFECTIVE_RANK = 100;
const REVOLUTION_BASE = 18;
const MIN_RANK = 3;
const MAX_RANK = 15;

class TycoonScene extends Phaser.Scene {
  constructor() {
    super();
    this.round = 1;                 // Current round
    this.ranks = [];                 // Store rank order per round
    this.deck = [];
    this.hands = [];
    this.table = [];
    this.currentPlayer = 0;
    this.revolution = false;

    this.selectedCards = [];
    this.selectedRank = null;
    this.passes = {};
    this.lastSetter = null;
    this.finishedPlayers = [];
    this.tableTexts = [];            // Initialize tableTexts
    this.handTexts = [];
    this.gameOver = false;           // Track game over state
  }

  preload() {}

  create() {
    this.startNextRound();

    // Pass button
    this.passBtn = this.add.text(50, 450, "[ PASS ]", {fontSize:"28px", color:"#f44", backgroundColor:"#222", padding:{x:10,y:5}})
      .setInteractive().on("pointerdown", ()=>this.playerPass());

    // Play button
    this.playBtn = this.add.text(200, 450, "[ PLAY ]", {fontSize:"28px", color:"#4f4", backgroundColor:"#222", padding:{x:10,y:5}})
      .setInteractive().on("pointerdown", ()=>this.playerAttemptPlay());
  }

  initDeck() {
    const suits=["♠","♥","♦","♣"];
    this.deck=[];
    for(let s of suits) for(let r=MIN_RANK;r<=MAX_RANK;r++) this.deck.push({rank:r,suit:s});
    this.deck.push({rank:JOKER_RANK,suit:"🃏"}); // Joker
    this.deck.push({rank:JOKER_RANK,suit:"🃏"}); // 2 Jokers
    Phaser.Utils.Array.Shuffle(this.deck);
  }

  dealCards(numPlayers){
    this.hands=Array.from({length:numPlayers},()=>[]);
    let i=0;
    while(this.deck.length>0){ this.hands[i%numPlayers].push(this.deck.pop()); i++; }
    this.hands.forEach(hand=>hand.sort((a,b)=>a.rank-b.rank));
  }

  cardToString(card){ 
    const ranks={11:"J",12:"Q",13:"K",14:"A",15:"2",16:"Joker"}; 
    return (ranks[card.rank]||card.rank)+card.suit; 
  }

  renderHand(playerIndex) {
    if (this.gameOver) return;

    if (this.handTexts) this.handTexts.forEach(t => t.destroy());
    this.handTexts = [];
    if (this.selectedCards.length === 0) this.selectedRank = null;

    let hand = this.hands[playerIndex];
    let topSet = this.getTopSet();
    let requiredCount = topSet ? topSet.length : 1;

    hand.forEach((card, i) => {
        let txt = this.add.text(50 + i * 40, 500, this.cardToString(card), { fontSize: "24px", color: "#fff" }).setInteractive();

        // Can select card logic
        let canSelect = false;

        if (!topSet) {
            canSelect = true;
        } else {
            let sameRank = hand.filter(c => c.rank === card.rank);
            let jokers = hand.filter(c => c.rank === JOKER_RANK);

            let candidate = sameRank.slice(0, requiredCount);
            if (candidate.length < requiredCount) candidate = candidate.concat(jokers.slice(0, requiredCount - candidate.length));

            if (candidate.length === requiredCount && this.canPlaySet(candidate)) canSelect = true;
        }

        if (this.selectedRank && card.rank !== this.selectedRank && card.rank !== JOKER_RANK) {
            canSelect = false;
        }

        txt.setAlpha(canSelect ? 1 : 0.3);

        if (this.selectedCards.includes(card)) {
            txt.setStyle({ backgroundColor: "#daa520", color: "#000" });
            txt.y -= 10;
        }

        txt.on("pointerdown", () => {
            if (!canSelect) return;
            this.toggleSelect(card);
        });

        this.handTexts.push(txt);
    });
}



toggleSelect(card) {
    if (this.gameOver || this.currentPlayer !== 0) return;

    let idx = this.selectedCards.indexOf(card);
    if (idx >= 0) {
        // Deselect
        this.selectedCards.splice(idx, 1);
        if (this.selectedCards.length === 0) this.selectedRank = null;
    } else {
        // Selecting a card
        if (this.selectedCards.length === 0) {
            // First selection: set selectedRank if not a Joker
            if (card.rank !== JOKER_RANK) this.selectedRank = card.rank;
        } else if (this.selectedRank && card.rank !== this.selectedRank && card.rank !== JOKER_RANK) {
            // Non-matching non-Joker replaces current selection
            this.selectedCards = [];
            this.selectedRank = card.rank;
        }
        this.selectedCards.push(card);
    }

    this.renderHand(0);
}



  getTopSet(){ return this.table.length>0?this.table[this.table.length-1]:null; }

  getEffectiveRank(card) {
    if (card.rank === JOKER_RANK) return JOKER_EFFECTIVE_RANK;
    if (!this.revolution) return card.rank;
    return REVOLUTION_BASE - card.rank; // Reverse order
  }

  canPlaySet(cards){
    if(cards.length===0) return false;
    if(cards.length === 1 && cards[0].rank === JOKER_RANK) return true;

    let nonJokers = cards.filter(c => c.rank !== JOKER_RANK);
    if(nonJokers.length === 0) return false;

    let baseRank = nonJokers[0].rank;
    if(!nonJokers.every(c => c.rank === baseRank)) return false;

    let topSet=this.getTopSet();
    if(!topSet) return true;

    if(cards.length!==topSet.length) return false;

    let top = topSet[0];
    let rank = baseRank;
    if(top.rank===JOKER_RANK && rank===3 && nonJokers[0].suit==="♠") return true;

    let topVal = this.getEffectiveRank(top);
    let newVal = this.getEffectiveRank({rank: rank});

    return newVal > topVal;
  }

  playerAttemptPlay(){
    if(this.gameOver || this.currentPlayer!==0) return;
    if(!this.canPlaySet(this.selectedCards)){ 
      this.statusText.setText("Invalid play!"); 
      this.time.delayedCall(1000, () => {
        if (this.currentPlayer === 0) this.statusText.setText("Your turn!");
      });
      return; 
    }
    this.playCard(0,this.selectedCards);
    this.selectedCards=[]; 
    this.selectedRank=null;
    this.renderHand(0);
    this.nextTurn();
  }

  playerPass(){
    if(this.gameOver || this.currentPlayer!==0) return;
    this.passes[0] = true;
    this.statusText.setText("You pass!");
    this.nextTurn();
  }

  playCard(playerIndex, cards) {
    this.hands[playerIndex] = this.hands[playerIndex].filter(c => !cards.includes(c));
    this.table.push(cards);
    this.lastSetter = playerIndex;
    this.passes = {};

    let yBase = 300;
    let spacingY = 60;
    let xCenter = 500;
    cards.forEach((card, i) => {
        let totalWidth = cards.length * 40;
        let x = xCenter - totalWidth / 2 + i * 40;
        let txt = this.add.text(x, yBase + (this.table.length - 1) * spacingY, this.cardToString(card), { fontSize: "28px", color: "#ff0" });
        this.tableTexts.push(txt);
    });

    // Flags for special pile clears
    let pileCleared = false;

    // 8-cut
    if (cards.some(c => c.rank === 8)) {
        this.clearPile("8-Cut!");
        pileCleared = true;
    }

    // 3♠ beats Joker
    let prevSet = this.table.length >= 2 ? this.table[this.table.length - 2] : null;
    if (prevSet && prevSet[0].rank === JOKER_RANK && cards[0].rank === 3 && cards[0].suit === "♠") {
        this.clearPile("3♠ beats Joker!");
        pileCleared = true;
    }

    if (cards.length === 4) {
        this.revolution = !this.revolution;
        let revText = this.add.text(300, 200, "REVOLUTION!", { fontSize: "32px", color: "#f0f" });
        this.time.delayedCall(2000, () => revText.destroy());
    }

    // Check if player emptied hand
    if (this.hands[playerIndex].length === 0) {
      this.finishedPlayers.push(playerIndex);
      this.endRound();
    }
  }

  clearPile(message){
    this.table=[];
    if(this.tableTexts){ this.tableTexts.forEach(t=>t.destroy()); this.tableTexts=[];}
    if(this.clearMsg) this.clearMsg.destroy();
    this.clearMsg=this.add.text(300,250,message,{fontSize:"28px",color:"#0f0"});
    this.clearMsg.setAlpha(1);
    this.tweens.add({targets:this.clearMsg,alpha:0,duration:1500,onComplete:()=>{if(this.clearMsg){this.clearMsg.destroy(); this.clearMsg=null;}}});
    this.passes = {};
    this.lastSetter = null;
  }

  aiTurn(playerIndex) {
    if (this.gameOver) return;
    
    let topSet = this.getTopSet();
    let requiredCount = topSet ? topSet.length : 1;
    
    // Get ranks of non-joker cards
    let ranks = [...new Set(this.hands[playerIndex].filter(c => c.rank !== JOKER_RANK).map(c => c.rank))];

    // Try non-joker cards first
    for (let r of ranks) {
        let sameRank = this.hands[playerIndex].filter(c => c.rank === r);
        let jokers = this.hands[playerIndex].filter(c => c.rank === JOKER_RANK);

        let candidate = sameRank.slice(0, requiredCount);
        if (candidate.length < requiredCount) candidate = candidate.concat(jokers.slice(0, requiredCount - candidate.length));

        if (candidate.length === requiredCount && this.canPlaySet(candidate)) {
            this.playCard(playerIndex, candidate);
            return;
        }
    }

    // Try to play a higher count set if possible
    if (!topSet) {
      for (let count = 2; count <= 4; count++) {
        for (let r of ranks) {
          let sameRank = this.hands[playerIndex].filter(c => c.rank === r);
          let jokers = this.hands[playerIndex].filter(c => c.rank === JOKER_RANK);
          
          if (sameRank.length + jokers.length >= count) {
            let candidate = sameRank.slice(0, count);
            if (candidate.length < count) candidate = candidate.concat(jokers.slice(0, count - candidate.length));
            
            if (this.canPlaySet(candidate)) {
              this.playCard(playerIndex, candidate);
              return;
            }
          }
        }
      }
    }

    // Only play a single Joker if table is empty or top set is not a Joker
    let singleJoker = this.hands[playerIndex].find(c => c.rank === JOKER_RANK);
    if (requiredCount === 1 && singleJoker) {
        if (!topSet || topSet[0].rank !== JOKER_RANK) {
            this.playCard(playerIndex, [singleJoker]);
            return;
        }
    }

    // Pass if nothing else works
    this.passes[playerIndex] = true;
  }

  nextTurn() {
    if (this.gameOver) return;

    // If the table is empty (pile just cleared), lastSetter starts
    if (this.table.length === 0 && this.lastSetter !== null) {
        this.currentPlayer = this.lastSetter;
    } else {
        // Normal turn rotation: skip players who have passed or have no cards
        do {
            this.currentPlayer = (this.currentPlayer + 1) % 4;
        } while (this.passes[this.currentPlayer] || this.hands[this.currentPlayer].length === 0);
    }

    // If only one player remains with cards, they win the round
    let playersWithCards = [0,1,2,3].filter(i => this.hands[i].length > 0);
    if (playersWithCards.length === 1) {
        this.finishedPlayers.push(playersWithCards[0]);
        this.endRound();
        return;
    }

    // Trigger next turn
    if (this.currentPlayer === 0) {
        this.statusText.setText("Your turn!");
        this.renderHand(0);
    } else {
        this.statusText.setText("AI " + this.currentPlayer + "'s turn...");
        this.time.delayedCall(500, () => {
            this.aiTurn(this.currentPlayer);
            this.time.delayedCall(500, () => this.nextTurn());
        });
    }
}


  // --- Rounds & Trading ---
  endRound() {
    // Add players who haven't finished yet in order of hand size
    let remainingPlayers = [0,1,2,3]
      .filter(i => !this.finishedPlayers.includes(i))
      .map(i => ({player: i, cardsLeft: this.hands[i].length}))
      .sort((a, b) => a.cardsLeft - b.cardsLeft)
      .map(x => x.player);
    
    let ranking = [...this.finishedPlayers, ...remainingPlayers];
    
    if(this.round > 1) ranking = this.adjustRankingForPreviousWinner(ranking);

    this.ranks.push(ranking);
    console.log("Round " + this.round + " ranking:", ranking);

    if(this.round >= 3){
      this.gameOver = true;
      this.statusText.setText("Game Over! Final rankings: " + ranking.join(", "));
      
      // Display final rankings
      this.add.text(300, 250, "Game Over!", { fontSize: "32px", color: "#ff0" });
      this.add.text(250, 300, "Final Rankings:", { fontSize: "24px", color: "#fff" });
      
      ranking.forEach((player, index) => {
        this.add.text(300, 340 + index * 30, `${index + 1}. Player ${player === 0 ? "You" : "AI " + player}`, 
                     { fontSize: "20px", color: "#fff" });
      });
      
      return;
    }

    this.round++;
    this.startNextRound();
  }

  adjustRankingForPreviousWinner(ranking){
    let prevFirst = this.ranks[this.ranks.length - 1][0];
    if(ranking[0] !== prevFirst){
        let idx = ranking.indexOf(prevFirst);
        ranking.splice(idx,1);
        ranking.unshift(prevFirst);
    }
    return ranking;
  }

  tradeCards() {
    let lastRound = this.ranks[this.ranks.length - 1];
    let [first, second, third, fourth] = lastRound;

    let firstHand = this.hands[first];
    let fourthHand = this.hands[fourth];
    let fourthHigh = [...fourthHand].sort((a,b)=>b.rank-a.rank).slice(0,2);
    fourthHigh.forEach(c => fourthHand.splice(fourthHand.indexOf(c),1));
    let firstGive = firstHand.slice(0,2);
    firstGive.forEach(c => firstHand.splice(firstHand.indexOf(c),1));
    firstHand.push(...fourthHigh);
    fourthHand.push(...firstGive);

    let secondHand = this.hands[second];
    let thirdHand = this.hands[third];
    let secondCard = secondHand[0];
    let thirdCard = thirdHand.sort((a,b)=>b.rank-a.rank)[0];
    secondHand.splice(secondHand.indexOf(secondCard),1);
    thirdHand.splice(thirdHand.indexOf(thirdCard),1);
    secondHand.push(thirdCard);
    thirdHand.push(secondCard);
  }

  startNextRound() {
    this.initDeck();
    this.dealCards(4);

    if(this.round > 1) this.tradeCards();

    this.table=[];
    this.passes={};
    this.lastSetter=null;
    this.currentPlayer=0;
    this.selectedCards=[];
    this.selectedRank=null;
    this.finishedPlayers=[];
    this.revolution = false;

    if(this.handTexts) this.handTexts.forEach(t=>t.destroy());
    this.handTexts=[];

    if(this.tableTexts) this.tableTexts.forEach(t=>t.destroy());
    this.tableTexts=[];
    
    if(this.statusText) this.statusText.destroy();
    this.statusText = this.add.text(20, 20, "Round " + this.round + " - Your turn!", {fontSize:"20px", color:"#fff"});

    this.renderHand(0);
  }
}

const config={type:Phaser.AUTO,width:1000,height:600,backgroundColor:"#2d2d2d",scene:TycoonScene};
new Phaser.Game(config);
</script>
</body>
</html>