<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Card Sandbox Hover Effect</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
<style>
html, body { margin:0; padding:0; width:100%; height:100%; background-color:#111; overflow:hidden; }
#game-container { width:100%; height:100%; position:relative; overflow:hidden; }
#game-container canvas { transform-origin: top left; display:block; position:absolute; }
</style>
</head>
<body>
<div id="game-container"></div>

<script>
class CardSandbox extends Phaser.Scene {
  constructor(){
    super();
    this.handCards = [];
    this.handImages = [];
    this.orderedFrames = [];
  }

  preload(){
    this.load.image('cardsheet', 'https://davymaldonado.github.io/tycoongame/cards.png');
  }

  create(){
    const cardWidth = 147;
    const cardHeight = 240;
    const leftMargin = 11;
    const topGap = 3;
    const columnGap = 22; 
    const rowGap = 4;     
    const suits = ['♣','♦','♥','♠'];

    this.frames = {};

    // --- Standard cards (rows 0–3) ---
    const ranks = [14,2,3,4,5,6,7,8,9,10,11,12]; // A=14, 2=2, 3-10=3-10, J=11, Q=12
    for(let r=0; r<4; r++){          
      const suit = suits[r];
      for(let c=0; c<12; c++){       
        const x = leftMargin + c * (cardWidth + columnGap);
        const y = topGap + r * (cardHeight + rowGap);
        const key = `${ranks[c]}${suit}`;
        this.frames[key] = {x, y, width: cardWidth, height: cardHeight};
        this.orderedFrames.push(key);
      }
    }

    // --- Special row ---
    const specialRowIndex = 4; 
    const specialCols = ['Joker','Joker','Back','K♣','K♦','K♥','K♠'];
    specialCols.forEach((key, colIndex)=>{
      const x = leftMargin + colIndex * (cardWidth + columnGap);
      const y = topGap + specialRowIndex * (cardHeight + rowGap);
      this.frames[key] = {x, y, width: cardWidth, height: cardHeight};
      if(key !== 'Back') this.orderedFrames.push(key);
    });

    this.time.delayedCall(50, () => this.renderHand());
  }

  createCardImage(frame){
    if (!frame) return null;
    const {x,y,width,height} = frame;
    const key = `card_${x}_${y}`;
    if(!this.textures.exists(key)){
      const img = this.textures.get('cardsheet').getSourceImage();
      const canvas = this.textures.createCanvas(key, width, height);
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, x, y, width, height, 0, 0, width, height);
      canvas.refresh();
    }
    return this.add.image(0,0,key);
  }

  shuffle(array){
    for(let i=array.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [array[i],array[j]] = [array[j],array[i]];
    }
    return array;
  }

  renderHand(){
    if(this.handImages) this.handImages.forEach(t=>t.destroy());
    this.handImages=[];

    // Pick 10 random cards
    const shuffled = this.shuffle([...this.orderedFrames]);
    this.handCards = shuffled.slice(0,14).map(key => ({key}));

    // --- Tycoon order: 3→10,J,Q,K,A,2, Jokers last ---
    const tycoonOrder = [3,4,5,6,7,8,9,10,11,12,13,14,2]; 
    const rankMap = {};
    tycoonOrder.forEach((r,i)=> rankMap[r]=i);

    this.handCards.sort((a,b)=>{
      if(a.key.includes('Joker')) return 1;
      if(b.key.includes('Joker')) return -1;

      const getRank = key => {
        if(key.startsWith('K')) return rankMap[13];
        if(key.startsWith('Q')) return rankMap[12];
        if(key.startsWith('J')) return rankMap[11];
        if(key.startsWith('A')) return rankMap[14];
        if(key.startsWith('2')) return rankMap[2];
        const numeric = parseInt(key);
        return rankMap[numeric] ?? 0;
      };

      const rankA = getRank(a.key);
      const rankB = getRank(b.key);
      if(rankA !== rankB) return rankA - rankB;

      const suitOrder = ['♣','♦','♥','♠'];
      const suitA = a.key.slice(-1);
      const suitB = b.key.slice(-1);
      return suitOrder.indexOf(suitA) - suitOrder.indexOf(suitB);
    });

    // --- Fanning parameters ---
    const screenWidth = 1280;
    const screenHeight = 720;
    const centerX = screenWidth / 2;
    const bottomY = screenHeight - 100;
    const baseSpacing = 70;
    const maxRotation = Phaser.Math.DegToRad(20);

    const updatePositions = (hoverIndex=null, scaleFactor=1.4)=>{
      const total = this.handCards.length;
      const totalWidth = baseSpacing * (total-1);
      const startX = centerX - totalWidth/2;

      for(let i=0;i<total;i++){
        const cardImg = this.handImages[i];
        const dx = (i - (total-1)/2) / ((total-1)/2);
        const rotation = dx * maxRotation;
        const y = bottomY - dx*dx*-50;

        let scale = 1;
        if(hoverIndex !== null && i === hoverIndex){
          scale = scaleFactor; // Only apply scale, no extra spacing
        }

        const x = startX + i*baseSpacing;
        cardImg.setPosition(x,y);
        cardImg.setRotation(rotation);
        cardImg.setScale(scale);
      }
    };

    // Create card images
    this.handCards.forEach((card,i)=>{
      const frame = this.frames[card.key];
      const img = this.createCardImage(frame).setOrigin(0.5,0.5);
      img.setData('index', i);
      img.setInteractive({useHandCursor:true});

      // Hover events
      img.on('pointerover', ()=>updatePositions(i));
      img.on('pointerout', ()=>updatePositions(null));

      this.handImages.push(img);
    });

    // Initial placement
    updatePositions(null);
  }
}

// Phaser config
const config = {
  type: Phaser.AUTO,
  width:1280,
  height:720,
  backgroundColor:"#1d1d1d",
  scene: CardSandbox,
  parent:"game-container"
};

const game = new Phaser.Game(config);

function resizeGame(){
  const container = document.getElementById("game-container");
  const canvas = container.querySelector("canvas");
  const scale = Math.min(container.clientWidth/1280, container.clientHeight/720);
  const offsetX = (container.clientWidth - 1280*scale)/2;
  const offsetY = (container.clientHeight - 720*scale)/2;
  canvas.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
}
window.addEventListener("resize", resizeGame);
window.addEventListener("load", resizeGame);
</script>
</body>
</html>
